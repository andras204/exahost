use std::fmt::Display;
use flume::{Sender, Receiver};
use serde::{Deserialize, Serialize};

use crate::{lexar::{*, self}, signal::ExaSignal};

#[derive(Debug, Clone)]
pub struct Exa {
    name: String,
    instr_list: Vec<String>,
    instr_ptr: u8,
    x_reg: Register,
    t_reg: Register,
    m_send: Sender<Register>,
    m_recv: Receiver<Register>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackedExa {
    name: String,
    instr_list: Vec<String>,
    instr_ptr: u8,
    x_reg: Register,
    t_reg: Register,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Register {
    Number(i16),
    Keyword(String),
}

impl Display for Register {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Number(n) => write!(f, "{}", n),
            Self::Keyword(w) => write!(f, "{}", w),
        }
    }
}

impl Register {
    fn from_token(token: &Token) -> Result<Register, &'static str> {
        match token.token_type {
            TokenType::Number => Ok(Register::Number(token.number().unwrap())),
            TokenType::Keyword => Ok(Register::Keyword(token.keyword().unwrap())),
            _ => Err("Invalid token type")
        }
    }

    fn number(&self) -> Result<i16, &str> {
        match self {
            Self::Number(n) => Ok(n.to_owned()),
            _ => Err("Not a number"),
        }
    }

    fn keyword(&self) -> Result<String, &str> {
        match self {
            Self::Keyword(w) => Ok(w.to_owned()),
            _ => Err("Not a keyword"),
        }
    }
}

impl PackedExa {
    pub fn new(name: &str, instr_list: Vec<String>) -> Result<Self, Vec<String>> {
        let code = lexar::compile(instr_list)?;
        Ok(PackedExa {
            name: name.to_string(),
            instr_list: code,
            instr_ptr: 0,
            x_reg: Register::Number(0),
            t_reg: Register::Number(0),
        })
    }

    pub fn unpack(self, m_send: Sender<Register>, m_recv: Receiver<Register>) -> Exa {
        Exa {
            name: self.name,
            instr_list: self.instr_list,
            instr_ptr: self.instr_ptr,
            x_reg: self.x_reg,
            t_reg: self.t_reg,
            m_send,
            m_recv,
        }
    }
}

impl Exa {
    pub fn pack(self) -> PackedExa {
        PackedExa {
            name: self.name,
            instr_list: self.instr_list,
            instr_ptr: self.instr_ptr,
            x_reg: self.x_reg,
            t_reg: self.t_reg,
        }
    }

    pub fn exec(&mut self) -> ExaSignal {
        if self.instr_ptr as usize == self.instr_list.len() { return ExaSignal::Err("Out of Instructions".to_string()); }
        let tokens: Vec<Token> = tokenize(self.instr_list[self.instr_ptr as usize].clone()).unwrap();
        self.instr_ptr += 1;
        if tokens[0].instruction().unwrap() == "mark".to_string() {
            return ExaSignal::Ok;
        }
        self.execute_instruction(tokens)
    }

    fn execute_instruction(&mut self, tokens: Vec<Token>) -> ExaSignal {
        match &tokens[0].instruction().unwrap()[..] {
            // I/O
            "copy" => self.copy(&tokens[1], &tokens[2]),
            // math
            "addi" => self.addi(&tokens[1], &tokens[2], &tokens[3]),
            "subi" => self.subi(&tokens[1], &tokens[2], &tokens[3]),
            "muli" => self.muli(&tokens[1], &tokens[2], &tokens[3]),
            "divi" => self.divi(&tokens[1], &tokens[2], &tokens[3]),
            "modi" => self.modi(&tokens[1], &tokens[2], &tokens[3]),
            // test
            "test" => self.test(&tokens[1], &tokens[2], &tokens[3]),
            // jumps
            "jump" => self.jump(&tokens[1]),
            "tjmp" => self.tjmp(&tokens[1]),
            "fjmp" => self.fjmp(&tokens[1]),
            // lifecycle
            "link" => self.link(&tokens[1]),
            "repl" => self.repl(&tokens[1]),
            "halt" => Self::halt(),
            "kill" => Self::kill(),
            // misc
            "prnt" => self.print(&tokens[1]),
            _ => ExaSignal::Err("Unknown instruction".to_string()),
        }
    }

    fn link(&self, link: &Token) -> ExaSignal {
        match self.get_number(link) {
            Ok(l) => ExaSignal::Link(l),
            Err(e) => ExaSignal::Err(e.to_string()),
        }
    }

    fn halt() -> ExaSignal {
        ExaSignal::Halt
    }

    fn kill() -> ExaSignal {
        ExaSignal::Kill
    }

    fn repl(&self, token: &Token) -> ExaSignal {
        let mut clone = self.clone();
        clone.jump(token);
        clone.name.push_str(":0");
        ExaSignal::Repl(clone)
    }

    fn addi(&mut self, op1: &Token, op2: &Token, target: &Token) -> ExaSignal {
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        *self.get_register_mut(target).unwrap() = Register::Number(num1 + num2);
        ExaSignal::Ok
    }

    fn subi(&mut self, op1: &Token, op2: &Token, target: &Token) -> ExaSignal {
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        *self.get_register_mut(target).unwrap() = Register::Number(num1 - num2);
        ExaSignal::Ok
    }

    fn muli(&mut self, op1: &Token, op2: &Token, target: &Token) -> ExaSignal {
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        *self.get_register_mut(target).unwrap() = Register::Number(num1 * num2);
        ExaSignal::Ok
    }

    fn divi(&mut self, op1: &Token, op2: &Token, target: &Token) -> ExaSignal {
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        *self.get_register_mut(target).unwrap() = Register::Number(num1 / num2);
        ExaSignal::Ok
    }

    fn modi(&mut self, op1: &Token, op2: &Token, target: &Token) -> ExaSignal {
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        *self.get_register_mut(target).unwrap() = Register::Number(num1 % num2);
        ExaSignal::Ok
    }

    fn test(&mut self, op1: &Token, comp: &Token, op2: &Token) -> ExaSignal {
        // TODO: handle non numbers
        let eval;
        let num1 = match self.get_number(op1) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        let num2 = match self.get_number(op2) {
            Ok(n) => n,
            Err(e) => return ExaSignal::Err(e.to_string()),
        };
        match &comp.comparison().unwrap()[..] {
            "=" => eval = num1 == num2,
            "!=" => eval = num1 != num2,
            ">=" => eval = num1 >= num2,
            "<=" => eval = num1 <= num2,
            ">" => eval = num1 > num2,
            "<" => eval = num1 < num2,
            _ => return ExaSignal::Err("Invalid Comparison".to_string()),
        }
        if eval { self.t_reg = Register::Number(1); }
        else { self.t_reg = Register::Number(0); }
        ExaSignal::Ok
    }

    fn jump(&mut self, arg: &Token) -> ExaSignal {
        let label = arg.label().unwrap();
        for x in 0..self.instr_list.len() {
            let tokens = split_instruction(self.instr_list[x].to_owned());
            if tokens[0] == "mark" && tokens[1] == label {
                self.instr_ptr = x as u8;
                return ExaSignal::Ok;
            }
        }
        ExaSignal::Err("Label not found".to_string())
    }

    fn tjmp(&mut self, arg: &Token) -> ExaSignal {
        if let Ok(t) = self.t_reg.number() {
            if t != 0 { self.jump(arg) }
            else { ExaSignal::Ok }
        }
        else { self.jump(arg) }
    }

    fn fjmp(&mut self, arg: &Token) -> ExaSignal {
        if let Ok(t) = self.t_reg.number() {
            if t == 0 { return self.jump(arg); }
        }
        ExaSignal::Ok
    }

    fn copy(&mut self, value: &Token, target: &Token) -> ExaSignal {
        let val: Register;
        match value.token_type {
            TokenType::Register => val = self.get_register_ref(value).unwrap().to_owned(),
            TokenType::Number | TokenType::Keyword => val = Register::from_token(value).unwrap(),
            _ => return ExaSignal::Err("Invalid argument type".to_string()),
        }
        *self.get_register_mut(target).unwrap() = val;
        ExaSignal::Ok
    }

    fn print(&self, arg: &Token) -> ExaSignal {
        match arg.token_type {
            TokenType::Register => println!("{}> {}", self.name, *self.get_register_ref(arg).unwrap()),
            TokenType::Keyword => println!("{}> {}", self.name, arg.keyword().unwrap()),
            _ => println!("{}> {}", self.name, arg.token),
        }
        ExaSignal::Ok
    }

    fn put_value(&mut self, value: Register, target: &Token) -> Result<(), &str> {
        let value = match value {
            Register::Number(n) => Self::clamp_value(n),
            Register::Keyword(w) => Register::Keyword(w),
        };

        match target.register().unwrap() {
            'x' => *self.get_register_mut('x').unwrap() = value,
            't' => *self.get_register_mut('t').unwrap() = value,
            'm' => {

            },
            _ => return Err("Invalid register"),
        }
        Ok(())
    }

    fn clamp_value(mut val: i16) -> Register {
        if val > 9999 { val = 9999; }
        if val < -9999 { val = -9999; }
        Register::Number(val)
    }

    fn get_register_ref(&self, arg: &Token) -> Result<&Register, &str> {
        match arg.register().unwrap() {
            'x' => Ok(&self.x_reg),
            't' => Ok(&self.t_reg),
            _ => Err("Invalid register"),
        }
    }

    fn get_register_mut(&mut self, reg: char) -> Result<&mut Register, &str> {
        match reg {
            'x' => Ok(&mut self.x_reg),
            't' => Ok(&mut self.t_reg),
            _ => Err("Invalid register"),
        }
    }

    fn get_number<'a>(&'a self, arg: &'a Token) -> Result<i16, &str> {
        match arg.token_type {
            TokenType::Register => {
                match arg.register().unwrap() {
                    'x' => self.x_reg.number(),
                    't' => self.t_reg.number(),
                    _ => return Err("Invalid register"),
                }
            }
            TokenType::Number => return arg.number(),
            _ => return Err("Not a number"),
        }
    }
}
